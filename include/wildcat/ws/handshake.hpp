
#ifndef WILDCAT_WS_HANDSHAKE_HPP
#define WILDCAT_WS_HANDSHAKE_HPP


#include <algorithm>
#include <random>
#include <sstream>
#include <string>
#include <unordered_map>
#include <iostream>
#include <cstring>
#include <poll.h>
#include <openssl/sha.h>
#include <wildcat/net/error.hpp>


namespace wildcat::ws {

    namespace {
        // base64 encode and decode functions from stackoverflow provide by user polfosol
        // https://stackoverflow.com/a/37109258
        const char *B64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

        const int B64index[256] = {
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 63, 62, 62, 63,
                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0,
                0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 63,
                0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
        };

        std::string b64encode(const void *data, const size_t &len) {
            std::string result((len + 2) / 3 * 4, '=');
            auto *p = (unsigned char *) data;
            char *str = &result[0];
            size_t j = 0, pad = len % 3;
            const size_t last = len - pad;

            for (size_t i = 0; i < last; i += 3) {
                int n = int(p[i]) << 16 | int(p[i + 1]) << 8 | p[i + 2];
                str[j++] = B64chars[n >> 18];
                str[j++] = B64chars[n >> 12 & 0x3F];
                str[j++] = B64chars[n >> 6 & 0x3F];
                str[j++] = B64chars[n & 0x3F];
            }
            if (pad)  /// Set padding
            {
                int n = --pad ? int(p[last]) << 8 | p[last + 1] : p[last];
                str[j++] = B64chars[pad ? n >> 10 & 0x3F : n >> 2];
                str[j++] = B64chars[pad ? n >> 4 & 0x03F : n << 4 & 0x3F];
                str[j++] = pad ? B64chars[n << 2 & 0x3F] : '=';
            }
            return result;
        }

        std::string b64decode(const void *data, const size_t &len) {
            if (len == 0) return "";

            auto *p = (unsigned char *) data;
            size_t j = 0,
                    pad1 = len % 4 || p[len - 1] == '=',
                    pad2 = pad1 && (len % 4 > 2 || p[len - 2] != '=');
            const size_t last = (len - pad1) / 4 << 2;
            std::string result(last / 4 * 3 + pad1 + pad2, '\0');
            auto *str = (unsigned char *) &result[0];

            for (size_t i = 0; i < last; i += 4) {
                int n = B64index[p[i]] << 18 | B64index[p[i + 1]] << 12 | B64index[p[i + 2]] << 6 | B64index[p[i + 3]];
                str[j++] = n >> 16;
                str[j++] = n >> 8 & 0xFF;
                str[j++] = n & 0xFF;
            }
            if (pad1) {
                int n = B64index[p[last]] << 18 | B64index[p[last + 1]] << 12;
                str[j++] = n >> 16;
                if (pad2) {
                    n |= B64index[p[last + 2]] << 6;
                    str[j++] = n >> 8 & 0xFF;
                }
            }
            return result;
        }

        /// Gets an http upgrade request
        std::string getUpgradeRequest(const std::string &host, const std::string &path, const std::string &key) {
            std::stringstream ss;
            ss << "GET /" << path << " HTTP/1.1\r\n";
            ss << "Host: " << host << "\r\n";
            ss << "Upgrade: websocket\r\n";
            ss << "Connection: Upgrade\r\n";
            ss << "Sec-WebSocket-Version: 13\r\n";
            ss << "Sec-WebSocket-Key: " << key << "\r\n";
            ss << "\r\n";
            return ss.str();
        }

    }

    /// Generate keys suitable for use in creating the Sec-WebSocket-Key for the handshake process
    class KeyGenerator {
    public:
        KeyGenerator() : rd_(), engine_(rd_()), distribution_(1, 255) {}

        /// Generates a vector of length `n` with randomly generated values
        std::vector<std::uint8_t> generate(std::size_t n) {
            std::vector<std::uint8_t> out(n);
            fill(out);
            return out;
        }

        /// Fills a vector with randomly generated values
        void fill(std::vector<std::uint8_t> &v) {
            for (auto &i: v) {
                i = distribution_(engine_);
            }
        }

    private:
        // https://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution
        std::random_device rd_;
        std::mt19937 engine_;
        std::uniform_int_distribution<uint8_t> distribution_;
    };

    namespace {
        /// Generates a base64 encoded string of randomly generated bytes
        static std::string generateKey() {
            KeyGenerator generator;
            const auto randKey = generator.generate(16);
            auto outKey = b64encode(randKey.data(), randKey.size());
            return outKey;
        }
    }


    class HttpResponse {
    public:
        using HeaderMap = std::unordered_map<std::string, std::string>;

        HttpResponse() : status_(), isComplete_(false), headers_() {}

        std::size_t parse(const char *buffer, std::size_t length) {
            auto response = std::string_view(buffer, length);
            const char *httpNewLine = "\r\n";

            // Keep the position in the buffer
            std::size_t pos = 0;

            // Find the position of the first delimiter
            pos = response.find_first_of(httpNewLine);
            if (pos == std::string::npos || pos == 0)
                return 0;

            // Get a view of the first line.
            const auto line = response.substr(0, pos);

            // Get the status
            if (sscanf(line.data(), "HTTP/1.1 %d", &status_) == -1) {
                // possible invalid version or just garbage response
                return 0;
            }

            // increment pos by 2 to get to the first character after \r\n
            pos += 2;
            while (pos < response.size()) {
                auto npos = response.find_first_of(httpNewLine, pos);
                if (npos == pos) {
                    // found the end delimiter
                    pos += 2;
                    isComplete_ = true;
                    break;
                }
                const auto line_ = response.substr(pos, npos - pos);
                auto n = line_.find_first_of(':');
                const auto key = std::string(line_.data(), n);
                auto value = std::string(line_.data() + (n + 1), line_.size() - (n + 1));
                value.erase(0, value.find_first_not_of(' '));
                headers_.insert_or_assign(key, value);
                pos = npos;
                pos += 2;
            }
            return pos;
        }

        /// Gets the status code of the response
        [[nodiscard]] int status() const noexcept {
            return status_;
        }

        /// Gets the headers of the response
        [[nodiscard]] const HeaderMap &headers() const noexcept {
            return headers_;
        }

        /// Gets true/false if a complete response was read and parsed
        [[nodiscard]] bool isComplete() const noexcept {
            return isComplete_;
        }

    private:
        int status_;
        bool isComplete_;
        HeaderMap headers_;
    };


    class HandshakeError : public std::exception {
    public:
        explicit HandshakeError(const std::string &msg) : msg_(msg) {}

        [[nodiscard]] const char *what() const noexcept override {
            return msg_.c_str();
        }

    private:
        std::string msg_;
    };

    namespace {
        std::string getAcceptKey(const std::string &key) {
            static const auto WS_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
            const auto magicString = key + WS_GUID;
            unsigned char md[20];
            SHA1(reinterpret_cast<const unsigned char *>(magicString.data()), magicString.size(), md);
            return b64encode(md, sizeof md);
        }
    }

    /// Manage the handshake process to upgrade the request
    template<class SocketStream_T>
    class Handshaker {
    public:

        /// Initiates the handshake
        static bool doHandshake(const std::string &host, const std::string &path, SocketStream_T *stream) {
            const auto key = generateKey();
            const auto acceptKey = getAcceptKey(key);
            const auto upgrade = getUpgradeRequest(host, path, key);

            // Write the upgrade request. Use poll to ensure socket is ready to write without blocking.
            struct pollfd pfd{};
            pfd.fd = stream->fd();
            pfd.events = POLLOUT;
            const auto pollTimeoutMillis = 5000;

            ssize_t bytesSent = 0;
            while (bytesSent < upgrade.size()) {
                const auto pollResult = poll(&pfd, 1, pollTimeoutMillis);
                if (pollResult != -1) {
                    bytesSent = stream->sendBytes(upgrade.data() + bytesSent, upgrade.size() - bytesSent);
                } else {
                    throw wildcat::net::IOError(errno, strerror(errno));
                }
            }

            // Receive the response
            HttpResponse response;
            std::array<char, 4096> buffer{};

            // Poll to ensure the socket is ready for reading.
            // Reuse the poll fd structure.
            pfd.events = POLLIN;

            std::size_t offset = 0;
            while (!response.isComplete()) {
                if (poll(&pfd, 1, pollTimeoutMillis) != -1) {
                    const auto bytesRead = stream->recvBytes(buffer.data() + offset, buffer.size() - offset);
                    offset += bytesRead;

                    response.parse(buffer.data(), offset);
                    if (response.isComplete()) {
                        return validateResponse(response, acceptKey);
                    }
                } else {
                    throw wildcat::net::IOError(errno, strerror(errno));
                }
            }
            return false;
        }

    private:
        static std::string tolower(const std::string &s) {
            // Create a copy of the input string
            auto out = std::string(s);
            std::transform(out.begin(), out.end(), out.begin(), [](unsigned char c) { return std::tolower(c); });
            return out;
        }

        static bool validateResponse(const HttpResponse &response, const std::string &acceptKey) {
            if (response.status() != 101) {
                std::string errMsg = "Unexpected response HTTP status code: ";
                errMsg += std::to_string(response.status());
                throw HandshakeError(errMsg);
            }

            // Get the headers from the http response
            const auto &headers = response.headers();

            // Upgrade: websocket
            {
                auto h = headers.find("Upgrade");
                if (h == headers.end()) {
                    // Upgrade header not present
                    throw HandshakeError("\"Upgrade\" header is missing in response");
                }

                if (tolower(h->second) != "websocket") {
                    std::string errMsg = "Unexpected value for Upgrade header: ";
                    errMsg += h->second;
                    throw HandshakeError(errMsg);
                }
            }

            // Connection: Upgrade
            {
                auto h = headers.find("Connection");
                if (h == headers.end()) {
                    throw HandshakeError("\"Connection\" header is missing in response");
                }

                if (tolower(h->second) != "upgrade") {
                    std::string errMsg = "Unexpected value for Connection header: ";
                    errMsg += h->second;
                    throw HandshakeError(errMsg);
                }
            }

            // Sec-WebSocket-Accept
            {
                const auto h = headers.find("Sec-WebSocket-Accept");
                if (h == headers.end()) {
                    throw HandshakeError("\"Sec-WebSocket-Accept\" header is missing in response");
                }

                if (acceptKey != h->second) {
                    throw HandshakeError("Invalid \"Sec-WebSocket-Accept\" header value. Failed to authenticate server response.");
                }
            }

            return true;
        }

    };

}

#endif //WILDCAT_WS_HANDSHAKE_HPP
